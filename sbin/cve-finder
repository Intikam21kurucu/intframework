#!/usr/bin/env python3
# Author: C.E Lopes
META = {
    "author": "C.E LOPES",
    "url": "https://github.com/cethegeek/cve-finder",
    "parsers": ["--keywords", "--recipients", "--smtpserver", "--help"],
    "desc": "A python Script that implements a simple command line function to search the recent Cve Releases by keyword",
    "app": "cve-finder"
}
from pyfiglet import *
from colorama import *
init(autoreset=True)
print(Fore.GREEN + Figlet(font='slant').renderText(META["app"]))
print()
print(META["desc"] + " from " + META["author"] + " url " + META["url"] + " parsers: " + str(META["parsers"]))
import click
import os
import urllib.request
import gzip
import json
import smtplib
from email.message import EmailMessage
from email.headerregistry import Address
from email.utils import make_msgid

CONTROL_FILE = './cve-finder.ctrl'

CVE_URL_TEMPLATE = 'https://nvd.nist.gov/vuln/detail/'
RECENT_META = 'https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-recent.meta'
RECENT_DATA = 'https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-recent.json.gz'
LAST_MODIFIED_KEY = 'lastModifiedDate'
LOCAL_DATA_ZIP = './cve-recent.json.gz'
SMTPSERVER = 'localhost'

def cleanupInput(arguments):
    """Reformats the input to look nicer if comma separated"""
    arguments = arguments.replace(',', ', ')
    arguments = " ".join(arguments.split())
    return arguments

def getLatestExecution():
    """Obtain the latest execution from the control file (if it exists)."""
    latestExecution = None

    try:
        if os.path.exists(CONTROL_FILE):
            with open(CONTROL_FILE, 'r') as control_file:
                latestExecution = control_file.read()
        return latestExecution 
    except Exception as e:
        print("**** FATAL ERROR ****")
        print(str(e))
        exit(1)

def hasPublishedNewCVE():
    """Validates that there is a new set of recent CVEs published since last run"""
    latestExecution = None
    latestModifiedDate = None
    try:
        response = urllib.request.urlopen(RECENT_META)
        for line in response:
            if LAST_MODIFIED_KEY in line.decode("utf-8"):
                latestModifiedDate = line.decode("utf-8").split(LAST_MODIFIED_KEY+':')[1].strip()
                break

        latestExecution = getLatestExecution()

        if (latestExecution is None or latestExecution < latestModifiedDate):
            with open(CONTROL_FILE, 'w+') as control_file:
                control_file.write(latestModifiedDate)

        return (latestExecution is None or latestExecution < latestModifiedDate)
    except Exception as e:
        print("**** FATAL ERROR ****")
        print(str(e))
        exit(1)

def downloadLatestVulnerabilities():
    """Downloads the CVE recent JSON payload"""
    try:
        # Write the gzip file locally first so we have it cached
        with urllib.request.urlopen(RECENT_DATA) as dl_file:
            with open(LOCAL_DATA_ZIP, 'wb') as out_zipped:
                out_zipped.write(dl_file.read())
    except Exception as e:
        print("**** FATAL ERROR ****")
        print(str(e))
        exit(1)

def find_CVE_by_keyword(keyword, json_data):
    """This contains the specific logic to process the JSON file from NIST. If that files change, this will have to change."""
    relevant = []
    for cve in json_data['CVE_Items']:
        if keyword.upper() in str(cve).upper():
            relevant_cve = {}
            relevant_cve['keyword'] = keyword
            relevant_cve['id'] = cve['cve']['CVE_data_meta']['ID']
            relevant_cve['url'] = CVE_URL_TEMPLATE + cve['cve']['CVE_data_meta']['ID']
            relevant_cve['reference'] = cve['cve']['references']['reference_data'][0]['url']
            relevant_cve['description'] = cve['cve']['description']['description_data'][0]['value']
            relevant.append(relevant_cve)
    return relevant

def format_text(relevant):
    """Given a dictionary of relevant CVEs, formats it for text output"""
    text_output = ""
    current_keyword = ""
    for relevant_cve in relevant:
        if (current_keyword != relevant_cve['keyword']):
            text_output += f'Keyword: {relevant_cve["keyword"]}\n'
            text_output += '=' * (9+len(relevant_cve['keyword']))
            text_output += '\n\n'
            current_keyword = relevant_cve['keyword']
        text_output += f'CVE        : {relevant_cve["url"]}\n'
        text_output += f'Reference  : {relevant_cve["reference"]}\n'
        text_output += f'Description: {relevant_cve["description"]}\n\n'
    return text_output

def format_html(relevant):
    """Given a dictionary of relevant CVEs, formats it for HTML output"""
    html_output = ""
    current_keyword = ""
    for relevant_cve in relevant:
        if (current_keyword != relevant_cve['keyword']):
            html_output += f'<h3>Keyword: {relevant_cve["keyword"]}</h3>\n'
            html_output += '<hr/>\n'
            current_keyword = relevant_cve['keyword']
        html_output += f'<p>\n'
        html_output += f'<a href="{relevant_cve["url"]}"><b>{relevant_cve["id"]}</b></a><br/>\n'
        html_output += f'<b>Reference:</b> <a href="{relevant_cve["reference"]}">{relevant_cve["reference"]}</a><br/>\n'
        html_output += f'<b>Description:</b> {relevant_cve["description"]}\n'
        html_output += f'</p>\n'
    return html_output

def send_to_recipients(keywords, recipients, html, text, smtpserver):
    try:
        msg = EmailMessage()
        msg['Subject'] = f"CVE report on {keywords}"
        msg['From'] = Address("Tech Support", "techsupport", "ndr.com")
        msg['To'] = recipients
        msg.set_content(text)
        mcid = make_msgid()
        msg.add_alternative(html.format(mcid=mcid[1:-1]), subtype='html')
        with smtplib.SMTP(smtpserver) as s:
            s.send_message(msg)
    except Exception as e:
        print("**** Couldn't reach SMTP Server ****")
        print(str(e))
        print("")
        print(text)

@click.command()
@click.option("--keywords", required=True, prompt="Enter one or more keywords to search (comma-separated)", default="liferay", help="Comma separated list of keywords.")
@click.option("--recipients", required=False, prompt="Email address(es) for report (leave blank for console output)", default="", help="The email address or addresses to receive the report. If not specified, output will be to std out.")
@click.option("--smtpserver", required=False, prompt="Provide an SMTPServer address", default="localhost", help="The smtpserver that will be used to send the report.")
def cve_finder(keywords, recipients, smtpserver):
    """Consults the NIST Vulnerability Database for recent vulnerabilities for a keyword or keywords."""
    keywords=cleanupInput(keywords)
    recipients=cleanupInput(recipients)
    click.echo(f"Looking for the keywords ({keywords}) in the NIST recent entries:")
    click.echo("")
    click.echo(f"* Checking if there is a new set of vulnerabilities to download...")
    if hasPublishedNewCVE():
        click.echo(f"* Downloading latest vulnerabilities...")
        downloadLatestVulnerabilities()
    else:
        latestExecution = getLatestExecution()
        click.echo(f"* No new list found. Using last known recent vulnerabilities from: {latestExecution}")

    click.echo(f"* Processing each keyword...")
    json_data = None
    with gzip.open(LOCAL_DATA_ZIP, 'rb') as zipFileData:
        json_data = json.load(zipFileData)

    relevant = []
    for keyword in keywords.split(","):
        click.echo(f"** Keyword: {keyword.strip()}")
        relevant.extend(find_CVE_by_keyword(keyword.strip(), json_data))

    if len(relevant) == 0:
        click.echo(f"* No matches to the keywords provided.")
        exit(0)

    click.echo(f"* Processed all keywords, formatting results...")
    click.echo()
    if recipients.strip() == "":
        click.echo(format_text(relevant))
    else:
        send_to_recipients(keywords, recipients, format_html(relevant), format_text(relevant), smtpserver)

if __name__ == '__main__':
    cve_finder()